#include <iostream>
#include <cmath>
using namespace std;
/*
1. 공식을 이용해 배열의 최대 값을 구한 뒤 정사각형을 만든다.
2. 배열에 소용돌이를 담는다 (how)

시작 점의 좌표와 끝점의 좌표를 알아내는 것은 쉽다.
대각선을 먼저 채우고 그 다음,,,
최대값을 R 이라 하자.
R을 구하는 방법은 r1,c1, r2,c2 중 최대 값이다.
METRIX 의 크기는 [2*R][2*R]이 된다.


3. 입력받은 좌표만큼 치환한 후 반복출력 한다.

(-3,-3) (2,0)


   -3 -2 -1  0  1  2  3
    --------------------
-3 |37 36 35 34 33 32 31
-2 |38 17 16 15 14 13 30
-1 |39 18  5  4  3 12 29
 0 |40 19  6  1  2 11 28
 1 |41 20  7  8  9 10 27
 2 |42 21 22 23 24 25 26
 3 |43 44 45 46 47 48 49

R = 3
(0,0) (5,3)
    0  1  2  3  4  5  6
    --------------------
 0 |37 36 35 34 33 32 31
 1 |38 17 16 15 14 13 30
 2 |39 18  5  4  3 12 29
 3 |40 19  6  1  2 11 28
 4 |41 20  7  8  9 10 27
 5 |42 21 22 23 24 25 26
 6 |43 44 45 46 47 48 49

오른쪽 아래 대각선은 1, 9, 25, 49 로 (2n-1)^2 형태로 나타난다.
오른쪽으로 1칸 이동, 1씩 증감, 8n 만큼 이동 (상,좌,하,우) -> 반복

    Q1. 인덱스 관리 어떻게 할건지?
    세부적으로

    * 모든 이동에는  증감을 담는다.
    1 의 경우 -> [오른쪽으로 1칸 이동] 위로 1칸, 왼쪽으로 2칸, 아래로 2칸, 오른쪽으로 2칸 (특이 케이스?)
    9의 경우 -> [오른쪽으로 1칸 이동] 위로 4칸, 왼쪽으로 4칸 ,아래로 4칸, 오른쪽으로 4칸
    25의 경우 -> [오른쪽으로 1칸 이동 ] 위로 6칸, 왼쪽으로 6칸, 아래로 6칸, 오른쪽으로 6칸


    Solution :  1) 배열을 0,0으로 시작하게끔 초기화, 중심 자리에 1 넣고 시작
                2) 대각석 오른쪽에 공식으로 제곱값 대입
                3) 1의 경우 예외처리, 그 외에는 2*n 만큼 반복해서 인덱스에 값 넣기
                4) 범위를 구해야 하는 좌표를 0,0을 기준으로 치환 후 반복 출력

*/

int r1, c1, r2, c2, R, METRIX[5000][5000];
void showMetrix(int x, int y, int r, int c)
{
    for (int i = x; i <= r; i++)
    {
        for (int j = y; j <= c; j++)
        {

            if (METRIX[i][j] < 10 && j != y)
                cout
                    << " " << METRIX[i][j] << " ";

            else
                cout << METRIX[i][j] << " ";
        }
        cout << endl;
    }
}
int main()
{
    cin >> r1 >> c1 >> r2 >> c2;

    R = max(abs(r1), abs(c1));
    R = max(R, abs(c2));
    R = max(R, abs(r2));
    for (int i = 0; i < 2 * R + 1; i++)
    {
        for (int j = 0; j < 2 * R + 1; j++)
        {
            METRIX[i][j] = 0;
        }
    }

    int e = 1;
    for (int i = R; i < 2 * R + 1; i++)
    {
        METRIX[i][i] = pow((2 * e - 1), 2);
        e++;
    }
    /*
    1 의 경우 -> [오른쪽으로 1칸 이동] 위로 1칸, 왼쪽으로 2칸, 아래로 2칸, 오른쪽으로 2칸 (특이 케이스?)
    9의 경우 -> [오른쪽으로 1칸 이동] 위로 4칸, 왼쪽으로 4칸 ,아래로 4칸, 오른쪽으로 4칸
    25의 경우 -> [오른쪽으로 1칸 이동 ] 위로 6칸, 왼쪽으로 6칸, 아래로 6칸, 오른쪽으로 6칸


    */
    e = 1;
    int x, y;
    for (int i = R; i < 2 * R; i++)
    {

        x = i;
        y = i;

        y++;
        METRIX[x][y] = METRIX[x][y - 1] + 1; // 오른쪽으로 1칸 이동
        if (e == 1)
        {
            x--;
            METRIX[x][y] = METRIX[x + 1][y] + 1;
        }
        else
        {
            for (int j = 0; j < 2 * e - 1; j++)
            { // 위로 2*e 칸 이동
                x--;
                METRIX[x][y] = METRIX[x + 1][y] + 1;
            }
        }

        for (int j = 0; j < 2 * e; j++)
        { //   왼쪽
            y--;
            METRIX[x][y] = METRIX[x][y + 1] + 1;
        }
        for (int j = 0; j < 2 * e; j++)
        { // 아래
            x++;
            METRIX[x][y] = METRIX[x - 1][y] + 1;
        }
        for (int j = 0; j < 2 * e; j++)
        { // 오른쪽
            y++;
            METRIX[x][y] = METRIX[x][y - 1] + 1;
        }

        e++;
    }
    int nx, ny, mx, my;
    nx = r1 + R;
    ny = c1 + R;
    mx = r2 + R;
    my = c2 + R;
    showMetrix(nx, ny, mx, my);
    return 0;
}